#####Semiparametric Difference in Differences#####
#' @title compute.spatt
#'
#' @description
#' \code{compute.spatt} implements the method of Abadie (2005); this is
#'  computed automatically in several other methods in the qte package
#'  but this function provides a standalone result when quantiles are not
#'  wanted/needed.
#' 
#' @param formla outcome variable on treatment
#' @param t last time period
#' @param tmin1 middle time period
#' @param x additional covariates if using propensity score
#' reweighting technique
#' @param dropalwaystreated boolean indicating whether in true panel data
#' context (when treatment can occur in any period) whether or
#' not previously treated observations should be dropped from the sample.
#' This functionality is not currently implemented
#' @param idname an id that identifies individual units over time
#' @param bootstrap.iter boolean passed that is passed in when this
#' method is used to compute standard errors
#' @param plot Binary indicating whether or not to plot the object
#' @param method How to estimate the propensity score
#' @param ydiscrete Used to indicate whether the outcome has any
#'  discrete parts in the distribution
#'
#' @return QTE object
#'
#' @keywords internal
compute.spatt <- function(formla, xformla=NULL, t, tmin1,
                               tname, x=NULL, data, weights=NULL, panel=FALSE,
                               dropalwaystreated=TRUE, idname,
                               bootstrap.iter=FALSE,
                               plot=FALSE,
                               method=c("logit","GMM","semiparametric",
                                   "simulation","direct"),
                               ydiscrete=FALSE) {
    form = as.formula(formla)
    dta = model.frame(terms(form,data=data),data=data) #or model.matrix
    colnames(dta) = c("y","treatment")
    yname="y"
    treat="treatment"
    wname="weights"
    data=cbind.data.frame(dta,data)

    if (dropalwaystreated) {
        ##do nothing
    }

    if (!is.null(weights)) {
        ww <- data$weights 
    } else {
        weights <- 2/nrow(data)
        ww <- weights
    }


    if (!bootstrap.iter) {
        ##first line gets the correct two years of data
        data = subset(data, (data[,tname]==tmin1 | data[,tname]==t))
        if (panel) {
            data = makeBalancedPanel(data, idname, tname)
        }
    }

    ##set up the x variables
    ##if (!(is.null(xformla))) {
    ##    x <- colnames(model.frame(terms(as.formula(xformla)), data=data))
    ##    data <- cbind(data[,c(yname,treat,idname,tname)],
    ##                  model.frame(terms(as.formula(xformla)), data=data))
    ##}

    if (!(is.null(xformla))) {
        x <- colnames(model.matrix(terms(as.formula(xformla)), data=data))
        data <- cbind(data[,c(yname,treat,idname,tname)],
                      model.matrix(terms(as.formula(xformla)), data=data))
        if (!is.null(weights)) {
            data <- cbind(data, weights=ww)
        }
    }
    
    ##just to make sure the factors are working ok
    data = droplevels(data)
    
    ##1) set up a dummy variable indicating whether the individual is 
    ##treated in the last period.

    ##a) get all the treated (in the last period) observations
    treated.t = data[data[,tname]==t & data[,treat]==1,]
    
    ##b) set ever.treated to 1 if observation is treated in last period
    ## don't think I need to do this anymore
    ##data$ever.treated = data$treatment
    ##data$ever.treated = 1*(data[,idname] %in% treated.t[,idname])  
    ##ever.treated = "ever.treated"
    ##treated.t$ever.treated = 1

    ##Generate subsets of the panel data based on time period and
    ##whether or not the observation is treated.  These will be used
    ##to calculate distributions below.  
    ##treated.tmin1 = data[ data[,tname] == tmin1 & 
    ##    data[,ever.treated] == 1, ]
    treated.tmin1 <- data[ data[,tname] == tmin1 & data[,treat]==1, ]
    ##treated at t-2
    
    ##untreated at t
    untreated.t = data[data[,tname]==t & data[,treat]==0,]
    
    ##untreated at t-1 & t-2
    untreated.tmin1 = data[ data[,tname] == tmin1 &
        data[,treat] == 0, ]

    ##Sort data and rely on having a balanced panel to get the change
    ## distributions right
    if (panel) {
        treated.t <- treated.t[order(treated.t[,idname]),]
        treated.tmin1 <- treated.tmin1[order(treated.tmin1[,idname]),]
        untreated.t <- untreated.t[order(untreated.t[,idname]),]
        untreated.tmin1 <- untreated.tmin1[order(untreated.tmin1[,idname]),]
    }
    

    ##calculate the att; this will be changed if there are covariates
    att = weighted.mean(treated.t[,yname], treated.t[,wname]) -
        weighted.mean(treated.tmin1[,yname], treated.tmin1[,wname]) -
                                             (weighted.mean(untreated.t[,yname], untreated.t[,yname]) -
                                              weighted.mean(untreated.tmin1[,yname], untreated.tmin1[,wname]))

   
    ##functionality with covariates is not yet implemented
    pscore.reg <- NULL #do this in case no covariates as we return this value
    if (!(is.null(x))) {
        ##Step 1: Propensity Score
        ##set up the data to do the propensity score re-weighting
        ##we need to bind the datasets back together to estimate pscore
        ##TODO: this would only work for panel data
        treated.t$changey = treated.t[,yname] - treated.tmin1[,yname]
        treated.t$ytmin1 = treated.tmin1[,yname]
        ##treated.tmin1$changey <- treated.tmin1[,yname] - treated.tmin2[,yname]
        untreated.t$changey = untreated.t[,yname] - untreated.tmin1[,yname]
        untreated.t$ytmin1 = untreated.tmin1[,yname]
        ##untreated.tmin1$changey <- untreated.tmin1[,yname] -
        ##    untreated.tmin2[,yname]
        pscore.data = rbind(treated.t, untreated.t)
        xmat = pscore.data[,x]
        pscore.data1 <- cbind(pscore.data[,treat], pscore.data[,x])
        colnames(pscore.data1)[1] <- "treatment"
        pscore.reg = glm(treatment ~ ., data=pscore.data1, ## as.matrix(xmat),
            family=binomial(link="logit"))
        pscore = fitted(pscore.reg)
        pscore.data$pscore <- pscore
        pD1 = nrow(treated.t)/nrow(untreated.t)

        treated.t <- pscore.data[1:nrow(treated.t),]
        untreated.t <- pscore.data[(nrow(treated.t)+1):nrow(pscore.data),]

        ##TODO: this will only work for panel
        ##TODO: double check that this formula is right...
        att <- weighted.mean(((pscore.data$changey)/pD1)*(pscore.data[,treat] - pscore) /
                    (1-pscore), pscore.data[,wname])
    }

    out <- QTE(qte=NULL, pscore.reg=pscore.reg,  ate=att, probs=NULL)
    class(out) <- "QTE"
    return(out)
}


#' @title spatt
#'
#' @description \code{spatt} computes the Average Treatment Effect on the
#'  Treated (ATT) using the method of Abadie (2005)
#'
#' @param formla The formula y ~ d where y is the outcome and d is the
#'  treatment indicator (d should be binary)
#' @param xformla A optional one sided formula for additional covariates that
#'  will be adjusted for.  E.g ~ age + education.  Additional covariates can
#'  also be passed by name using the x paramater.
#' @param t The 3rd time period in the sample (this is the name of the column)
#' @param tmin1 The 2nd time period in the sample (this is the name of the
#'  column)
#' @param tname The name of the column containing the time periods
#' @param x An optional vector of covariates (the name of the columns).
#'  Covariates can also be passed in formulat notation using the
#'  xformla paramter.
#' @param data The name of the data.frame that contains the data
#' @param panel Boolean indicating whether the data is panel or repeated cross
#'  sections
#' @param dropalwaystreated How to handle always treated observations
#'  in panel data case (not currently used)
#' @param idname The individual (cross-sectional unit) id name
#' @param iters The number of iterations to compute bootstrap standard errors.
#'  This is only used if se=TRUE
#' @param alp The significance level used for constructing bootstrap
#'  confidence intervals
#' @param method The method for estimating the propensity score when covariates
#'  are included
#' @param plot Boolean whether or not the estimated QTET should be plotted
#' @param se Boolean whether or not to compute standard errors
#' @param retEachIter Boolean whether or not to return list of results
#'  from each iteration of the bootstrap procedure
#' @param seedvec Optional value to set random seed; can possibly be used
#'  in conjunction with bootstrapping standard errors.
#' @param weights additional (usually sampling) weights to be applied (not yet
#'  implemented)
#'
#' @examples
#' ##load the data
#' data(lalonde)
#'
#' ## Run the panel.qtet method on the experimental data with no covariates
#' att1 <- spatt(re ~ treat, t=1978, tmin1=1975, tname="year",
#'  x=NULL, data=lalonde.psid.panel, idname="id", se=FALSE)
#' summary(att1)
#'
#' ## Run the panel.qtet method on the observational data with no covariates
#' 
#'
#' @references
#' Abadie (2005)
#'
#' @return \code{QTE} object
#' 
#' @export
spatt <- function(formla, xformla=NULL, t, tmin1,
                      tname, x=NULL, data, weights=NULL, panel=FALSE,
                      dropalwaystreated=TRUE, idname, 
                      iters=100, alp=0.05, method="logit", plot=FALSE, se=TRUE,
                      retEachIter=FALSE, seedvec=NULL) {
    ##browser()
    form = as.formula(formla)
    dta = model.frame(terms(form,data=data),data=data) #or model.matrix
    colnames(dta) = c("y","treatment")
    yname="y"
    wname="weights"
    treat="treatment"
    data=cbind.data.frame(dta,data)


    data = subset(data, (data[,tname]==tmin1 | data[,tname]==t))
    if (panel) {
        data = makeBalancedPanel(data, idname, tname)
    }

    if (dropalwaystreated) {
        ##does nothing
    }
    
    ##just to make sure the factors are working ok
    data = droplevels(data)

    ##set the weights to be just 1; i.e. weights don't work yet
    data$weights <- 1
    
    ##
    treated.t = data[data[,tname]==t & data[,treat]==1,]
    treated.tmin1 = data[ data[,tname] == tmin1 & data[,treat] == 1, ]
    untreated.t = data[data[,tname]==t & data[,treat]==0,]
    untreated.tmin1 = data[ data[,tname] == tmin1 & data[,treat] == 0, ]

    ##first calculate the actual estimate
    att1 = compute.spatt(formla=formla, t=t, tmin1=tmin1,
        tname=tname, x=x, xformla=xformla, data=data, weights=weights, panel=panel,
        dropalwaystreated=dropalwaystreated,
        idname=idname, 
        method=method)

    if (se) {
        ##now calculate the bootstrap confidence interval
        eachIter = list()
        ##Need to build dataset by sampling individuals, and then
        ##taking all of their time periods
        if (panel) {
            treated.t <- treated.t[order(treated.t[,idname]),]
            treated.tmin1 <- treated.tmin1[order(treated.tmin1[,idname]),]
            untreated.t <- untreated.t[order(untreated.t[,idname]),]
            untreated.tmin1 <- untreated.tmin1[order(untreated.tmin1[,idname]),]
        }

        nt <- nrow(treated.t)
        nttmin1 <- nrow(treated.tmin1)
        nu <- nrow(untreated.t)
        nutmin1 <- nrow(untreated.tmin1)
        ##out.bootdatalist <<- list()
        for (i in 1:iters) {
            ##reset boot.data
            ##boot.data = data[0,]
            if(!is.null(seedvec)) {
                set.seed(seedvec[i])
            }
            randy.t <- sample(1:nt, nt, replace=T)
            randy.ttmin1 <- sample(1:nttmin1, nttmin1, replace=T)
            randy.u <- sample(1:nu, nu, replace=T)
            randy.utmin1 <- sample(1:nutmin1, nutmin1, replace=T)
            ##there has to be a way to do this faster, but go with the loop
            ##for now
            ##for (j in all.ids[randy]) {
            ##    boot.data = rbind(boot.data, data[(data[,idname]==j),])
            ##}
            ##these.ids <- data[,idname][randy]
            boot.data.treated.t <- treated.t[randy.t, ]
            boot.data.untreated.t <- untreated.t[randy.u, ]
            if (panel) {
                boot.data.treated.tmin1 <- treated.tmin1[randy.t, ]
                boot.data.untreated.tmin1 <- untreated.tmin1[randy.u, ]
            } else { ## this samples repeated cross sections separately;
                ## and I think implies independent sampling assumption
                boot.data.treated.tmin1 <- treated.tmin1[randy.ttmin1, ]
                boot.data.untreated.tmin1 <- untreated.tmin1[randy.utmin1, ]
            }
            boot.data <- rbind(boot.data.treated.t, boot.data.untreated.t,
                               boot.data.treated.tmin1,
                               boot.data.untreated.tmin1)
            ##need to set the ids right
            if (panel) {
                boot.data[,idname] <- paste(boot.data[,idname],
                                        c(seq(1, nt+nu), seq(1, nt+nu)),sep="-")
            }
            
            ##boot.data = process.bootdata(boot.data, idname, uniqueid)
            thisIter = compute.spatt(formla=formla, t=t, tmin1=tmin1,
                tname=tname, x=x, xformla=xformla, data=boot.data, weights=weights, panel=panel,
                dropalwaystreated=dropalwaystreated,
                idname=idname,  
                method=method,
                bootstrap.iter=TRUE)
            eachIter[[i]] = thisIter
                ##old
                ##list(att=thisIter$att, qte=thisIter$qte,
                ##        F.treated.t=thisIter$F.treated.t,
                ##        F.treated.t.cf=thisIter$F.treated.t.cf)
        }

        SEobj <- computeSE(eachIter, att1, alp=alp)

        if(!retEachIter) {
            eachIter=NULL
        }

        ##could return each bootstrap iteration w/ eachIter
        ##but not currently doing that
        out <- QTE(qte=NULL, ate=att1$ate,
                    ate.upper=SEobj$ate.upper, ate.lower=SEobj$ate.lower,
                    ate.se=SEobj$ate.se,
                    pscore.reg=att1$pscore.reg,
                    eachIterList=eachIter,
                    probs=NULL)
        return(out)
    } else {
        return(att1)
    }
}
